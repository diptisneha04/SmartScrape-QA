¶
To parse a document, pass it into theBeautifulSoupconstructor. You can pass in a string or an open filehandle:
BeautifulSoup
BeautifulSoup
frombs4importBeautifulSoupwithopen("index.html")asfp:soup=BeautifulSoup(fp,'html.parser')soup=BeautifulSoup("<html>a web page</html>",'html.parser')
frombs4importBeautifulSoupwithopen("index.html")asfp:soup=BeautifulSoup(fp,'html.parser')soup=BeautifulSoup("<html>a web page</html>",'html.parser')
frombs4importBeautifulSoupwithopen("index.html")asfp:soup=BeautifulSoup(fp,'html.parser')soup=BeautifulSoup("<html>a web page</html>",'html.parser')

from
bs4
import
BeautifulSoup
with
open
(
"index.html"
)
as
fp
:
soup
=
BeautifulSoup
(
fp
,
'html.parser'
)
soup
=
BeautifulSoup
(
"<html>a web page</html>"
,
'html.parser'
)
First, the document is converted to Unicode, and HTML entities are
converted to Unicode characters:
print(BeautifulSoup("<html><head></head><body>Sacr&eacute; bleu!</body></html>","html.parser"))# <html><head></head><body>Sacré bleu!</body></html>
print(BeautifulSoup("<html><head></head><body>Sacr&eacute; bleu!</body></html>","html.parser"))# <html><head></head><body>Sacré bleu!</body></html>
print(BeautifulSoup("<html><head></head><body>Sacr&eacute; bleu!</body></html>","html.parser"))# <html><head></head><body>Sacré bleu!</body></html>

print
(
BeautifulSoup
(
"<html><head></head><body>Sacr&eacute; bleu!</body></html>"
,
"html.parser"
))
# <html><head></head><body>Sacré bleu!</body></html>
Beautiful Soup then parses the document using the best available
parser. It will use an HTML parser unless you specifically tell it to
use an XML parser. (SeeParsing XML.)
Parsing XML
Kinds of objects¶Beautiful Soup transforms a complex HTML document into a complex tree
of Python objects. But you'll only ever have to deal with about fourkindsof objects:Tag,NavigableString,BeautifulSoup,
andComment. These objects represent the HTMLelementsthat comprise the page.classTag¶ATagobject corresponds to an XML or HTML tag in the original document.soup=BeautifulSoup('<b class="boldest">Extremely bold</b>','html.parser')tag=soup.btype(tag)# <class 'bs4.element.Tag'>Tags have a lot of attributes and methods, and I'll cover most of them
inNavigating the treeandSearching the tree. For now, the most
important methods of a tag are for accessing its name and attributes.name¶Every tag has a name:tag.name# 'b'If you change a tag's name, the change will be reflected in any
markup generated by Beautiful Soup down the line:tag.name="blockquote"tag# <blockquote class="boldest">Extremely bold</blockquote>attrs¶An HTML or XML tag may have any number of attributes. The tag<bid="boldest">has an attribute "id" whose value is
"boldest". You can access a tag's attributes by treating the tag like
a dictionary:tag=BeautifulSoup('<b id="boldest">bold</b>','html.parser').btag['id']# 'boldest'You can access the dictionary of attributes directly as.attrs:tag.attrs# {'id': 'boldest'}tag.attrs.keys()# dict_keys(['id'])You can add, remove, and modify a tag's attributes. Again, this is
done by treating the tag as a dictionary:tag['id']='verybold'tag['another-attribute']=1tag# <b another-attribute="1" id="verybold"></b>deltag['id']deltag['another-attribute']tag# <b>bold</b>tag['id']# KeyError: 'id'tag.get('id')# NoneMulti-valued attributes¶HTML 4 defines a few attributes that can have multiple values. HTML 5
removes a couple of them, but defines a few more. The most common
multi-valued attribute isclass(that is, a tag can have more than
one CSS class). Others includerel,rev,accept-charset,headers, andaccesskey. By default, Beautiful Soup stores the value(s)
of a multi-valued attribute as a list:css_soup=BeautifulSoup('<p class="body"></p>','html.parser')css_soup.p['class']# ['body']css_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser')css_soup.p['class']# ['body', 'strikeout']When you turn a tag back into a string, the values of any multi-valued
attributes are consolidated:rel_soup=BeautifulSoup('<p>Back to the <a rel="index first">homepage</a></p>','html.parser')rel_soup.a['rel']# ['index', 'first']rel_soup.a['rel']=['index','contents']print(rel_soup.p)# <p>Back to the <a rel="index contents">homepage</a></p>If an attributelookslike it has more than one value, but it's not
a multi-valued attribute as defined by any version of the HTML
standard, Beautiful Soup stores it as a simple string:id_soup=BeautifulSoup('<p id="my id"></p>','html.parser')id_soup.p['id']# 'my id'You can force all attributes to be stored as strings by passingmulti_valued_attributes=Noneas a keyword argument into theBeautifulSoupconstructor:no_list_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser',multi_valued_attributes=None)no_list_soup.p['class']# 'body strikeout'You can useget_attribute_listto always return the value in a list
container, whether it's a string or multi-valued attribute value:id_soup.p['id']# 'my id'id_soup.p.get_attribute_list('id')# ["my id"]If you parse a document as XML, there are no multi-valued attributes:xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml')xml_soup.p['class']# 'body strikeout'Again, you can configure this using themulti_valued_attributesargument:class_is_multi={'*':'class'}xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml',multi_valued_attributes=class_is_multi)xml_soup.p['class']# ['body', 'strikeout']You probably won't need to do this, but if you do, use the defaults as
a guide. They implement the rules described in the HTML specification:frombs4.builderimportbuilder_registrybuilder_registry.lookup('html').DEFAULT_CDATA_LIST_ATTRIBUTESclassNavigableString¶A tag can contain strings as pieces of text. Beautiful Soup
uses theNavigableStringclass to contain these pieces of text:soup=BeautifulSoup('<b class="boldest">Extremely bold</b>','html.parser')tag=soup.btag.string# 'Extremely bold'type(tag.string)# <class 'bs4.element.NavigableString'>ANavigableStringis just like a Python Unicode string, except
that it also supports some of the features described inNavigating
the treeandSearching the tree. You can convert aNavigableStringto a Unicode string withstr:unicode_string=str(tag.string)unicode_string# 'Extremely bold'type(unicode_string)# <type 'str'>You can't edit a string in place, but you can replace one string with
another, usingreplace_with():tag.string.replace_with("No longer bold")tag# <b class="boldest">No longer bold</b>NavigableStringsupports most of the features described inNavigating the treeandSearching the tree, but not all of
them. In particular, since a string can't contain anything (the way a
tag may contain a string or another tag), strings don't support the.contentsor.stringattributes, or thefind()method.If you want to use aNavigableStringoutside of Beautiful Soup,
you should callunicode()on it to turn it into a normal Python
Unicode string. If you don't, your string will carry around a
reference to the entire Beautiful Soup parse tree, even when you're
done using Beautiful Soup. This is a big waste of memory.TheBeautifulSoupobject represents the parsed document as a
whole. For most purposes, you can treat it as aTagobject. This means it supports most of the methods described inNavigating the treeandSearching the tree.You can also pass aBeautifulSoupobject into one of the methods
defined inModifying the tree, just as you would aTag. This
lets you do things like combine two parsed documents:doc=BeautifulSoup("<document><content/>INSERT FOOTER HERE</document","xml")footer=BeautifulSoup("<footer>Here's the footer</footer>","xml")doc.find(text="INSERT FOOTER HERE").replace_with(footer)# 'INSERT FOOTER HERE'print(doc)# <?xml version="1.0" encoding="utf-8"?># <document><content/><footer>Here's the footer</footer></document>Since theBeautifulSoupobject doesn't correspond to an actual
HTML or XML tag, it has no name and no attributes. But sometimes it's
useful to reference its.name(such as when writing code that works
with bothTagandBeautifulSoupobjects),
so it's been given the special.name"[document]":soup.name# '[document]'Special strings¶Tag,NavigableString, andBeautifulSoupcover almost everything you'll see in an
HTML or XML file, but there are a few leftover bits. The main one
you'll probably encounter is theComment.classComment¶markup="<b><!--Hey, buddy. Want to buy a used parser?--></b>"soup=BeautifulSoup(markup,'html.parser')comment=soup.b.stringtype(comment)# <class 'bs4.element.Comment'>TheCommentobject is just a special type ofNavigableString:comment# 'Hey, buddy. Want to buy a used parser'But when it appears as part of an HTML document, aCommentis
displayed with special formatting:print(soup.b.prettify())# <b>#  <!--Hey, buddy. Want to buy a used parser?--># </b>For HTML documents¶Beautiful Soup defines a fewNavigableStringsubclasses to
contain strings found inside specific HTML tags. This makes it easier
to pick out the main body of the page, by ignoring strings that
probably represent programming directives found within the
page.(These classes are new in Beautiful Soup 4.9.0, and the
html5lib parser doesn't use them.)classStylesheet¶ANavigableStringsubclass that represents embedded CSS
stylesheets; that is, any strings found inside a<style>tag
during document parsing.classScript¶ANavigableStringsubclass that represents embedded
Javascript; that is, any strings found inside a<script>tag
during document parsing.classTemplate¶ANavigableStringsubclass that represents embedded HTML
templates; that is, any strings found inside a<template>tag during
document parsing.For XML documents¶Beautiful Soup defines someNavigableStringclasses for
holding special types of strings that can be found in XML
documents. LikeComment, these classes are subclasses ofNavigableStringthat add something extra to the string on
output.classDeclaration¶ANavigableStringsubclass representing thedeclarationat the beginning of
an XML document.classDoctype¶ANavigableStringsubclass representing thedocument type
declarationwhich may
be found near the beginning of an XML document.classCData¶ANavigableStringsubclass that represents aCData section.classProcessingInstruction¶ANavigableStringsubclass that represents the contents
of anXML processing instruction.