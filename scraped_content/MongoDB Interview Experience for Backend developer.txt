MongoDB Interview Experience for Backend developer Last Updated : 05 Apr, 2024 Comments Improve Suggest changes Like Article Like Report Skype Round 1 (60 minutes): Convert a given array into a linked list. https://www.geeksforgeeks.org/create-linked-list-from-a-given-array/ I wrote a solution that inserts elements at the end of the linked list for every new element and kept track of the last node so that the next inserts are O(1). I missed some edge cases, but overall the interviewer was happy with my code. I don’t exactly remember the 2nd question. It seemed like a typical coding contest question with a long description, but the question’s core was greedy algorithms and the solution was based on sorting. Since there was more time left, the interviewer asked general technical questions. He asked about the how’s and why’s of dependency injection and how it enables inversion of control. Skype Round 2 (60 minutes): Implement a queue using arrays. https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/ The interviewer didn’t mention circular queues initially, but I started my discussion directly with circular queues since it was more efficient in terms of storage. But as I progressed I got stuck on the edge cases of queue boundary detections for too long and also the interviewer got a little confused with the arithmetic modulus operations that I was using. I completely bombed this question and my confidence just died from here. The interviewer paused the coding question and started asking general technical questions. He asked me to explain the CAP theorem in layman’s terms and how it’s applicable in distributed systems. He then asked me about design patterns I knew and where I’ve used them for which I answered singleton, builder, and factory but I couldn’t give him an example for factory pattern. He then asked me questions about my current work. In the end, the interviewer sounded very positive and asked me to brush up my knowledge in data structures and algorithms and he also mentioned that he hoped to see me for onsite rounds soon. I was almost sure that I wouldn’t go beyond this round. Luckily a few days later, I got an email from recruiters to confirm my availability for onsite rounds. I spent a good amount of time brushing up on data structures, algorithms, and system design. Onsite Round 1 (60 minutes): How to replicate data across multiple data centers (DCs)? He mentioned that it was an open-ended question and asked me to think of different solutions. I initially proposed using NoSQL solutions like Cassandra and Dynamo DB to keep multiple nodes from different DCs in the cluster and keep the consistency level the way we want. He then challenged me to not use built-in solutions after which I proposed running local consumers in each DC waiting for updates to be synced when a source DC gets written. There were more follow-up questions, but since I had little to no experience with distributed systems, I felt like I didn’t make a good impression here. After this, he asked me to do a whiteboard of the high-level design of my current project and I was able to give him a clear picture. Onsite Round 2 (60 minutes): Following questions were asked: Find the length of the path from node A to node B in a binary tree. https://www.geeksforgeeks.org/find-distance-between-two-nodes-of-a-binary-tree/ I was familiar with this kinda problem. The heart of the problem is to find the Lowest Common Ancestor (LCA) of the two nodes and then find the height of node A and node B from the LCA node. The sum of these two heights gives the distance between the two nodes. I was asked to write code on a whiteboard. Given a matrix containing only 1’s and 0’s, find the largest square sub-matrix which contains only 1’s. https://www.geeksforgeeks.org/problems/largest-square-formed-in-a-matrix0806/1 This is a medium hard dynamic programming problem. The goal is to define the recursive state DP[i][j] which is the size of the largest square sub-matrix that ends at Matrix[i][j]. DP[i][j] can be derived from its sub-problems DP[i-1][j], DP[i-1][j-1] and DP[i][j-1] based on content of Matrix[i][j]. Onsite Round 3 (60 minutes): This round was with an engineering manager and we initially had some small talks and directly jumped into questions: Egg dropping problem: Given 2 eggs and a 100-floor building, find the minimum egg drops required in worst the case to find the first floor at which the egg breaks. https://www.geeksforgeeks.org/puzzle-set-35-2-eggs-and-100-floors/ https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors/ This is a very tricky question and I’ve faced this question before in a previous interview during my campus placements and I couldn’t solve it then. My confidence dropped a little but I started with a brute force solution, where I start dropping the egg from the ground floor one floor at a time, but it was very inefficient as it takes 100 drops in the worst case and only uses 1 egg. Next, I thought about binary search where I start on the 50th floor and proceed to halve each time, but it was still inefficient but better than brute force. Next, I tried to divide the floor into block sizes of B floors i.e 100/B blocks in total. I would start dropping eggs from the topmost floor in each block and proceed this way. I wrote a mathematical function in terms of B for the worst case and differentiated it to get the optimal value of B: PSEUDO CODE: F(B) = (100/B) + (B-1) Apply differentiation to get optimal B F'(B) = 0 (-100/B*B) + 1 - 0 = 0 B = 10 Worst case attempts = F(10) = (100/10) + (10-1) = 19 attempts I thought I nailed it this time but to my amazement, it was still not the right answer. But the interviewer said I was close to the final answer. I couldn’t figure out the final solution for myself but with some help from the interviewer, I was able to derive the solution. It’s a modification of my fixed blocks approach but the difference is that the block sizes shouldn’t be fixed and we should try to take bigger block sizes at the bottom and reduce the block size as we go up. The correct answer was 14. See this video  https://youtu.be/uBhSIKLlvdk for a proper explanation. Since there was some more time left he asked some general technical questions mostly about databases like NoSQL vs SQL, ACID properties, when to use NoSQL over a SQL DB, etc. The interviewer kept a poker face all the time, so I wasn’t sure how this round went. Onsite Round 4 (60 minutes): Design a sim card store system that gives you 3 sim cards on demand and each of them has a 10-digit long phone number. The generated numbers should be very hard to predict We need to keep track of the phone numbers that are sold out and also the total unused numbers the system has at any point in time. Phone numbers should be stored very efficiently and retrieval of available phone numbers should be fast. I went with a naive approach of using a database that had all the possible 10-digit numbers which will be stored as one record each with additional metadata. He challenged me and said that it didn’t meet the requirements of storage efficiency and randomness. I thought for some more time and got the idea of using a Trie data structure since it’s the most efficient way to store strings. I did a white-boarding using trie as the data store and showed him that phone numbers with the same prefixes will share the same nodes and will give huge efficiency in terms of storage. Since we need 10-digit long phone numbers the Trie will be 10 levels deep and each Trie node will have 10 child nodes (i.e for digits 0 to 9). At any time, when we request available numbers we can make it unpredictable by picking any digit from 0 to 9 randomly at each trie node. To keep track of the count of available phone numbers we can keep additional metadata at each node i.e when a 10-digit number is sold, we can increment the count in every trie node involved in that 10-digit number and with this, the root trie node will have the total sold-out numbers for each starting digit from 0 to 9. The interviewer liked the idea and he started challenging availability and consistency issues. We discussed running a standby trie data store, caching, saving the trie to disk periodically, etc. Overall this round went well. Comment More info Advertise with us Next Article Cypherock Interview Experience for SDE Internship Anonymous Improve Article Tags : Experiences Interview Experiences