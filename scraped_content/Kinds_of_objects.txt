¶
Beautiful Soup transforms a complex HTML document into a complex tree
of Python objects. But you'll only ever have to deal with about fourkindsof objects:Tag,NavigableString,BeautifulSoup,
andComment. These objects represent the HTMLelementsthat comprise the page.
kinds
Tag
Tag
Tag
NavigableString
NavigableString
NavigableString
BeautifulSoup
BeautifulSoup
Comment
Comment
Comment
elements
classTag¶ATagobject corresponds to an XML or HTML tag in the original document.soup=BeautifulSoup('<b class="boldest">Extremely bold</b>','html.parser')tag=soup.btype(tag)# <class 'bs4.element.Tag'>Tags have a lot of attributes and methods, and I'll cover most of them
inNavigating the treeandSearching the tree. For now, the most
important methods of a tag are for accessing its name and attributes.name¶Every tag has a name:tag.name# 'b'If you change a tag's name, the change will be reflected in any
markup generated by Beautiful Soup down the line:tag.name="blockquote"tag# <blockquote class="boldest">Extremely bold</blockquote>attrs¶An HTML or XML tag may have any number of attributes. The tag<bid="boldest">has an attribute "id" whose value is
"boldest". You can access a tag's attributes by treating the tag like
a dictionary:tag=BeautifulSoup('<b id="boldest">bold</b>','html.parser').btag['id']# 'boldest'You can access the dictionary of attributes directly as.attrs:tag.attrs# {'id': 'boldest'}tag.attrs.keys()# dict_keys(['id'])You can add, remove, and modify a tag's attributes. Again, this is
done by treating the tag as a dictionary:tag['id']='verybold'tag['another-attribute']=1tag# <b another-attribute="1" id="verybold"></b>deltag['id']deltag['another-attribute']tag# <b>bold</b>tag['id']# KeyError: 'id'tag.get('id')# NoneMulti-valued attributes¶HTML 4 defines a few attributes that can have multiple values. HTML 5
removes a couple of them, but defines a few more. The most common
multi-valued attribute isclass(that is, a tag can have more than
one CSS class). Others includerel,rev,accept-charset,headers, andaccesskey. By default, Beautiful Soup stores the value(s)
of a multi-valued attribute as a list:css_soup=BeautifulSoup('<p class="body"></p>','html.parser')css_soup.p['class']# ['body']css_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser')css_soup.p['class']# ['body', 'strikeout']When you turn a tag back into a string, the values of any multi-valued
attributes are consolidated:rel_soup=BeautifulSoup('<p>Back to the <a rel="index first">homepage</a></p>','html.parser')rel_soup.a['rel']# ['index', 'first']rel_soup.a['rel']=['index','contents']print(rel_soup.p)# <p>Back to the <a rel="index contents">homepage</a></p>If an attributelookslike it has more than one value, but it's not
a multi-valued attribute as defined by any version of the HTML
standard, Beautiful Soup stores it as a simple string:id_soup=BeautifulSoup('<p id="my id"></p>','html.parser')id_soup.p['id']# 'my id'You can force all attributes to be stored as strings by passingmulti_valued_attributes=Noneas a keyword argument into theBeautifulSoupconstructor:no_list_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser',multi_valued_attributes=None)no_list_soup.p['class']# 'body strikeout'You can useget_attribute_listto always return the value in a list
container, whether it's a string or multi-valued attribute value:id_soup.p['id']# 'my id'id_soup.p.get_attribute_list('id')# ["my id"]If you parse a document as XML, there are no multi-valued attributes:xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml')xml_soup.p['class']# 'body strikeout'Again, you can configure this using themulti_valued_attributesargument:class_is_multi={'*':'class'}xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml',multi_valued_attributes=class_is_multi)xml_soup.p['class']# ['body', 'strikeout']You probably won't need to do this, but if you do, use the defaults as
a guide. They implement the rules described in the HTML specification:frombs4.builderimportbuilder_registrybuilder_registry.lookup('html').DEFAULT_CDATA_LIST_ATTRIBUTES
classTag¶
class
class

Tag
Tag
¶
ATagobject corresponds to an XML or HTML tag in the original document.soup=BeautifulSoup('<b class="boldest">Extremely bold</b>','html.parser')tag=soup.btype(tag)# <class 'bs4.element.Tag'>Tags have a lot of attributes and methods, and I'll cover most of them
inNavigating the treeandSearching the tree. For now, the most
important methods of a tag are for accessing its name and attributes.name¶Every tag has a name:tag.name# 'b'If you change a tag's name, the change will be reflected in any
markup generated by Beautiful Soup down the line:tag.name="blockquote"tag# <blockquote class="boldest">Extremely bold</blockquote>attrs¶An HTML or XML tag may have any number of attributes. The tag<bid="boldest">has an attribute "id" whose value is
"boldest". You can access a tag's attributes by treating the tag like
a dictionary:tag=BeautifulSoup('<b id="boldest">bold</b>','html.parser').btag['id']# 'boldest'You can access the dictionary of attributes directly as.attrs:tag.attrs# {'id': 'boldest'}tag.attrs.keys()# dict_keys(['id'])You can add, remove, and modify a tag's attributes. Again, this is
done by treating the tag as a dictionary:tag['id']='verybold'tag['another-attribute']=1tag# <b another-attribute="1" id="verybold"></b>deltag['id']deltag['another-attribute']tag# <b>bold</b>tag['id']# KeyError: 'id'tag.get('id')# NoneMulti-valued attributes¶HTML 4 defines a few attributes that can have multiple values. HTML 5
removes a couple of them, but defines a few more. The most common
multi-valued attribute isclass(that is, a tag can have more than
one CSS class). Others includerel,rev,accept-charset,headers, andaccesskey. By default, Beautiful Soup stores the value(s)
of a multi-valued attribute as a list:css_soup=BeautifulSoup('<p class="body"></p>','html.parser')css_soup.p['class']# ['body']css_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser')css_soup.p['class']# ['body', 'strikeout']When you turn a tag back into a string, the values of any multi-valued
attributes are consolidated:rel_soup=BeautifulSoup('<p>Back to the <a rel="index first">homepage</a></p>','html.parser')rel_soup.a['rel']# ['index', 'first']rel_soup.a['rel']=['index','contents']print(rel_soup.p)# <p>Back to the <a rel="index contents">homepage</a></p>If an attributelookslike it has more than one value, but it's not
a multi-valued attribute as defined by any version of the HTML
standard, Beautiful Soup stores it as a simple string:id_soup=BeautifulSoup('<p id="my id"></p>','html.parser')id_soup.p['id']# 'my id'You can force all attributes to be stored as strings by passingmulti_valued_attributes=Noneas a keyword argument into theBeautifulSoupconstructor:no_list_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser',multi_valued_attributes=None)no_list_soup.p['class']# 'body strikeout'You can useget_attribute_listto always return the value in a list
container, whether it's a string or multi-valued attribute value:id_soup.p['id']# 'my id'id_soup.p.get_attribute_list('id')# ["my id"]If you parse a document as XML, there are no multi-valued attributes:xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml')xml_soup.p['class']# 'body strikeout'Again, you can configure this using themulti_valued_attributesargument:class_is_multi={'*':'class'}xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml',multi_valued_attributes=class_is_multi)xml_soup.p['class']# ['body', 'strikeout']You probably won't need to do this, but if you do, use the defaults as
a guide. They implement the rules described in the HTML specification:frombs4.builderimportbuilder_registrybuilder_registry.lookup('html').DEFAULT_CDATA_LIST_ATTRIBUTES
ATagobject corresponds to an XML or HTML tag in the original document.
Tag
Tag
Tag
soup=BeautifulSoup('<b class="boldest">Extremely bold</b>','html.parser')tag=soup.btype(tag)# <class 'bs4.element.Tag'>
soup=BeautifulSoup('<b class="boldest">Extremely bold</b>','html.parser')tag=soup.btype(tag)# <class 'bs4.element.Tag'>
soup=BeautifulSoup('<b class="boldest">Extremely bold</b>','html.parser')tag=soup.btype(tag)# <class 'bs4.element.Tag'>

soup
=
BeautifulSoup
(
'<b class="boldest">Extremely bold</b>'
,
'html.parser'
)
tag
=
soup
.
b
type
(
tag
)
# <class 'bs4.element.Tag'>
Tags have a lot of attributes and methods, and I'll cover most of them
inNavigating the treeandSearching the tree. For now, the most
important methods of a tag are for accessing its name and attributes.
Navigating the tree
Searching the tree
name¶Every tag has a name:tag.name# 'b'If you change a tag's name, the change will be reflected in any
markup generated by Beautiful Soup down the line:tag.name="blockquote"tag# <blockquote class="boldest">Extremely bold</blockquote>
name¶
name
name
¶
Every tag has a name:tag.name# 'b'If you change a tag's name, the change will be reflected in any
markup generated by Beautiful Soup down the line:tag.name="blockquote"tag# <blockquote class="boldest">Extremely bold</blockquote>
Every tag has a name:
tag.name# 'b'
tag.name# 'b'
tag.name# 'b'

tag
.
name
# 'b'
If you change a tag's name, the change will be reflected in any
markup generated by Beautiful Soup down the line:
tag.name="blockquote"tag# <blockquote class="boldest">Extremely bold</blockquote>
tag.name="blockquote"tag# <blockquote class="boldest">Extremely bold</blockquote>
tag.name="blockquote"tag# <blockquote class="boldest">Extremely bold</blockquote>

tag
.
name
=
"blockquote"
tag
# <blockquote class="boldest">Extremely bold</blockquote>
attrs¶An HTML or XML tag may have any number of attributes. The tag<bid="boldest">has an attribute "id" whose value is
"boldest". You can access a tag's attributes by treating the tag like
a dictionary:tag=BeautifulSoup('<b id="boldest">bold</b>','html.parser').btag['id']# 'boldest'You can access the dictionary of attributes directly as.attrs:tag.attrs# {'id': 'boldest'}tag.attrs.keys()# dict_keys(['id'])You can add, remove, and modify a tag's attributes. Again, this is
done by treating the tag as a dictionary:tag['id']='verybold'tag['another-attribute']=1tag# <b another-attribute="1" id="verybold"></b>deltag['id']deltag['another-attribute']tag# <b>bold</b>tag['id']# KeyError: 'id'tag.get('id')# NoneMulti-valued attributes¶HTML 4 defines a few attributes that can have multiple values. HTML 5
removes a couple of them, but defines a few more. The most common
multi-valued attribute isclass(that is, a tag can have more than
one CSS class). Others includerel,rev,accept-charset,headers, andaccesskey. By default, Beautiful Soup stores the value(s)
of a multi-valued attribute as a list:css_soup=BeautifulSoup('<p class="body"></p>','html.parser')css_soup.p['class']# ['body']css_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser')css_soup.p['class']# ['body', 'strikeout']When you turn a tag back into a string, the values of any multi-valued
attributes are consolidated:rel_soup=BeautifulSoup('<p>Back to the <a rel="index first">homepage</a></p>','html.parser')rel_soup.a['rel']# ['index', 'first']rel_soup.a['rel']=['index','contents']print(rel_soup.p)# <p>Back to the <a rel="index contents">homepage</a></p>If an attributelookslike it has more than one value, but it's not
a multi-valued attribute as defined by any version of the HTML
standard, Beautiful Soup stores it as a simple string:id_soup=BeautifulSoup('<p id="my id"></p>','html.parser')id_soup.p['id']# 'my id'You can force all attributes to be stored as strings by passingmulti_valued_attributes=Noneas a keyword argument into theBeautifulSoupconstructor:no_list_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser',multi_valued_attributes=None)no_list_soup.p['class']# 'body strikeout'You can useget_attribute_listto always return the value in a list
container, whether it's a string or multi-valued attribute value:id_soup.p['id']# 'my id'id_soup.p.get_attribute_list('id')# ["my id"]If you parse a document as XML, there are no multi-valued attributes:xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml')xml_soup.p['class']# 'body strikeout'Again, you can configure this using themulti_valued_attributesargument:class_is_multi={'*':'class'}xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml',multi_valued_attributes=class_is_multi)xml_soup.p['class']# ['body', 'strikeout']You probably won't need to do this, but if you do, use the defaults as
a guide. They implement the rules described in the HTML specification:frombs4.builderimportbuilder_registrybuilder_registry.lookup('html').DEFAULT_CDATA_LIST_ATTRIBUTES
attrs¶
attrs
attrs
¶
An HTML or XML tag may have any number of attributes. The tag<bid="boldest">has an attribute "id" whose value is
"boldest". You can access a tag's attributes by treating the tag like
a dictionary:tag=BeautifulSoup('<b id="boldest">bold</b>','html.parser').btag['id']# 'boldest'You can access the dictionary of attributes directly as.attrs:tag.attrs# {'id': 'boldest'}tag.attrs.keys()# dict_keys(['id'])You can add, remove, and modify a tag's attributes. Again, this is
done by treating the tag as a dictionary:tag['id']='verybold'tag['another-attribute']=1tag# <b another-attribute="1" id="verybold"></b>deltag['id']deltag['another-attribute']tag# <b>bold</b>tag['id']# KeyError: 'id'tag.get('id')# NoneMulti-valued attributes¶HTML 4 defines a few attributes that can have multiple values. HTML 5
removes a couple of them, but defines a few more. The most common
multi-valued attribute isclass(that is, a tag can have more than
one CSS class). Others includerel,rev,accept-charset,headers, andaccesskey. By default, Beautiful Soup stores the value(s)
of a multi-valued attribute as a list:css_soup=BeautifulSoup('<p class="body"></p>','html.parser')css_soup.p['class']# ['body']css_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser')css_soup.p['class']# ['body', 'strikeout']When you turn a tag back into a string, the values of any multi-valued
attributes are consolidated:rel_soup=BeautifulSoup('<p>Back to the <a rel="index first">homepage</a></p>','html.parser')rel_soup.a['rel']# ['index', 'first']rel_soup.a['rel']=['index','contents']print(rel_soup.p)# <p>Back to the <a rel="index contents">homepage</a></p>If an attributelookslike it has more than one value, but it's not
a multi-valued attribute as defined by any version of the HTML
standard, Beautiful Soup stores it as a simple string:id_soup=BeautifulSoup('<p id="my id"></p>','html.parser')id_soup.p['id']# 'my id'You can force all attributes to be stored as strings by passingmulti_valued_attributes=Noneas a keyword argument into theBeautifulSoupconstructor:no_list_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser',multi_valued_attributes=None)no_list_soup.p['class']# 'body strikeout'You can useget_attribute_listto always return the value in a list
container, whether it's a string or multi-valued attribute value:id_soup.p['id']# 'my id'id_soup.p.get_attribute_list('id')# ["my id"]If you parse a document as XML, there are no multi-valued attributes:xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml')xml_soup.p['class']# 'body strikeout'Again, you can configure this using themulti_valued_attributesargument:class_is_multi={'*':'class'}xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml',multi_valued_attributes=class_is_multi)xml_soup.p['class']# ['body', 'strikeout']You probably won't need to do this, but if you do, use the defaults as
a guide. They implement the rules described in the HTML specification:frombs4.builderimportbuilder_registrybuilder_registry.lookup('html').DEFAULT_CDATA_LIST_ATTRIBUTES
An HTML or XML tag may have any number of attributes. The tag<bid="boldest">has an attribute "id" whose value is
"boldest". You can access a tag's attributes by treating the tag like
a dictionary:
<bid="boldest">
<b
id="boldest">
tag=BeautifulSoup('<b id="boldest">bold</b>','html.parser').btag['id']# 'boldest'
tag=BeautifulSoup('<b id="boldest">bold</b>','html.parser').btag['id']# 'boldest'
tag=BeautifulSoup('<b id="boldest">bold</b>','html.parser').btag['id']# 'boldest'

tag
=
BeautifulSoup
(
'<b id="boldest">bold</b>'
,
'html.parser'
)
.
b
tag
[
'id'
]
# 'boldest'
You can access the dictionary of attributes directly as.attrs:
.attrs
.attrs
tag.attrs# {'id': 'boldest'}tag.attrs.keys()# dict_keys(['id'])
tag.attrs# {'id': 'boldest'}tag.attrs.keys()# dict_keys(['id'])
tag.attrs# {'id': 'boldest'}tag.attrs.keys()# dict_keys(['id'])

tag
.
attrs
# {'id': 'boldest'}
tag
.
attrs
.
keys
()
# dict_keys(['id'])
You can add, remove, and modify a tag's attributes. Again, this is
done by treating the tag as a dictionary:
tag['id']='verybold'tag['another-attribute']=1tag# <b another-attribute="1" id="verybold"></b>deltag['id']deltag['another-attribute']tag# <b>bold</b>tag['id']# KeyError: 'id'tag.get('id')# None
tag['id']='verybold'tag['another-attribute']=1tag# <b another-attribute="1" id="verybold"></b>deltag['id']deltag['another-attribute']tag# <b>bold</b>tag['id']# KeyError: 'id'tag.get('id')# None
tag['id']='verybold'tag['another-attribute']=1tag# <b another-attribute="1" id="verybold"></b>deltag['id']deltag['another-attribute']tag# <b>bold</b>tag['id']# KeyError: 'id'tag.get('id')# None

tag
[
'id'
]
=
'verybold'
tag
[
'another-attribute'
]
=
1
tag
# <b another-attribute="1" id="verybold"></b>
del
tag
[
'id'
]
del
tag
[
'another-attribute'
]
tag
# <b>bold</b>
tag
[
'id'
]
# KeyError: 'id'
tag
.
get
(
'id'
)
# None
Multi-valued attributes¶HTML 4 defines a few attributes that can have multiple values. HTML 5
removes a couple of them, but defines a few more. The most common
multi-valued attribute isclass(that is, a tag can have more than
one CSS class). Others includerel,rev,accept-charset,headers, andaccesskey. By default, Beautiful Soup stores the value(s)
of a multi-valued attribute as a list:css_soup=BeautifulSoup('<p class="body"></p>','html.parser')css_soup.p['class']# ['body']css_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser')css_soup.p['class']# ['body', 'strikeout']When you turn a tag back into a string, the values of any multi-valued
attributes are consolidated:rel_soup=BeautifulSoup('<p>Back to the <a rel="index first">homepage</a></p>','html.parser')rel_soup.a['rel']# ['index', 'first']rel_soup.a['rel']=['index','contents']print(rel_soup.p)# <p>Back to the <a rel="index contents">homepage</a></p>If an attributelookslike it has more than one value, but it's not
a multi-valued attribute as defined by any version of the HTML
standard, Beautiful Soup stores it as a simple string:id_soup=BeautifulSoup('<p id="my id"></p>','html.parser')id_soup.p['id']# 'my id'You can force all attributes to be stored as strings by passingmulti_valued_attributes=Noneas a keyword argument into theBeautifulSoupconstructor:no_list_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser',multi_valued_attributes=None)no_list_soup.p['class']# 'body strikeout'You can useget_attribute_listto always return the value in a list
container, whether it's a string or multi-valued attribute value:id_soup.p['id']# 'my id'id_soup.p.get_attribute_list('id')# ["my id"]If you parse a document as XML, there are no multi-valued attributes:xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml')xml_soup.p['class']# 'body strikeout'Again, you can configure this using themulti_valued_attributesargument:class_is_multi={'*':'class'}xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml',multi_valued_attributes=class_is_multi)xml_soup.p['class']# ['body', 'strikeout']You probably won't need to do this, but if you do, use the defaults as
a guide. They implement the rules described in the HTML specification:frombs4.builderimportbuilder_registrybuilder_registry.lookup('html').DEFAULT_CDATA_LIST_ATTRIBUTES

Multi-valued attributes¶
¶
HTML 4 defines a few attributes that can have multiple values. HTML 5
removes a couple of them, but defines a few more. The most common
multi-valued attribute isclass(that is, a tag can have more than
one CSS class). Others includerel,rev,accept-charset,headers, andaccesskey. By default, Beautiful Soup stores the value(s)
of a multi-valued attribute as a list:
class
class
rel
rel
rev
rev
accept-charset
accept-charset
headers
headers
accesskey
accesskey
css_soup=BeautifulSoup('<p class="body"></p>','html.parser')css_soup.p['class']# ['body']css_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser')css_soup.p['class']# ['body', 'strikeout']
css_soup=BeautifulSoup('<p class="body"></p>','html.parser')css_soup.p['class']# ['body']css_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser')css_soup.p['class']# ['body', 'strikeout']
css_soup=BeautifulSoup('<p class="body"></p>','html.parser')css_soup.p['class']# ['body']css_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser')css_soup.p['class']# ['body', 'strikeout']

css_soup
=
BeautifulSoup
(
'<p class="body"></p>'
,
'html.parser'
)
css_soup
.
p
[
'class'
]
# ['body']
css_soup
=
BeautifulSoup
(
'<p class="body strikeout"></p>'
,
'html.parser'
)
css_soup
.
p
[
'class'
]
# ['body', 'strikeout']
When you turn a tag back into a string, the values of any multi-valued
attributes are consolidated:
rel_soup=BeautifulSoup('<p>Back to the <a rel="index first">homepage</a></p>','html.parser')rel_soup.a['rel']# ['index', 'first']rel_soup.a['rel']=['index','contents']print(rel_soup.p)# <p>Back to the <a rel="index contents">homepage</a></p>
rel_soup=BeautifulSoup('<p>Back to the <a rel="index first">homepage</a></p>','html.parser')rel_soup.a['rel']# ['index', 'first']rel_soup.a['rel']=['index','contents']print(rel_soup.p)# <p>Back to the <a rel="index contents">homepage</a></p>
rel_soup=BeautifulSoup('<p>Back to the <a rel="index first">homepage</a></p>','html.parser')rel_soup.a['rel']# ['index', 'first']rel_soup.a['rel']=['index','contents']print(rel_soup.p)# <p>Back to the <a rel="index contents">homepage</a></p>

rel_soup
=
BeautifulSoup
(
'<p>Back to the <a rel="index first">homepage</a></p>'
,
'html.parser'
)
rel_soup
.
a
[
'rel'
]
# ['index', 'first']
rel_soup
.
a
[
'rel'
]
=
[
'index'
,
'contents'
]
print
(
rel_soup
.
p
)
# <p>Back to the <a rel="index contents">homepage</a></p>
If an attributelookslike it has more than one value, but it's not
a multi-valued attribute as defined by any version of the HTML
standard, Beautiful Soup stores it as a simple string:
looks
id_soup=BeautifulSoup('<p id="my id"></p>','html.parser')id_soup.p['id']# 'my id'
id_soup=BeautifulSoup('<p id="my id"></p>','html.parser')id_soup.p['id']# 'my id'
id_soup=BeautifulSoup('<p id="my id"></p>','html.parser')id_soup.p['id']# 'my id'

id_soup
=
BeautifulSoup
(
'<p id="my id"></p>'
,
'html.parser'
)
id_soup
.
p
[
'id'
]
# 'my id'
You can force all attributes to be stored as strings by passingmulti_valued_attributes=Noneas a keyword argument into theBeautifulSoupconstructor:
multi_valued_attributes=None
multi_valued_attributes=None
BeautifulSoup
BeautifulSoup
no_list_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser',multi_valued_attributes=None)no_list_soup.p['class']# 'body strikeout'
no_list_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser',multi_valued_attributes=None)no_list_soup.p['class']# 'body strikeout'
no_list_soup=BeautifulSoup('<p class="body strikeout"></p>','html.parser',multi_valued_attributes=None)no_list_soup.p['class']# 'body strikeout'

no_list_soup
=
BeautifulSoup
(
'<p class="body strikeout"></p>'
,
'html.parser'
,
multi_valued_attributes
=
None
)
no_list_soup
.
p
[
'class'
]
# 'body strikeout'
You can useget_attribute_listto always return the value in a list
container, whether it's a string or multi-valued attribute value:
get_attribute_list
get_attribute_list
id_soup.p['id']# 'my id'id_soup.p.get_attribute_list('id')# ["my id"]
id_soup.p['id']# 'my id'id_soup.p.get_attribute_list('id')# ["my id"]
id_soup.p['id']# 'my id'id_soup.p.get_attribute_list('id')# ["my id"]

id_soup
.
p
[
'id'
]
# 'my id'
id_soup
.
p
.
get_attribute_list
(
'id'
)
# ["my id"]
If you parse a document as XML, there are no multi-valued attributes:
xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml')xml_soup.p['class']# 'body strikeout'
xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml')xml_soup.p['class']# 'body strikeout'
xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml')xml_soup.p['class']# 'body strikeout'

xml_soup
=
BeautifulSoup
(
'<p class="body strikeout"></p>'
,
'xml'
)
xml_soup
.
p
[
'class'
]
# 'body strikeout'
Again, you can configure this using themulti_valued_attributesargument:
multi_valued_attributes
multi_valued_attributes
class_is_multi={'*':'class'}xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml',multi_valued_attributes=class_is_multi)xml_soup.p['class']# ['body', 'strikeout']
class_is_multi={'*':'class'}xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml',multi_valued_attributes=class_is_multi)xml_soup.p['class']# ['body', 'strikeout']
class_is_multi={'*':'class'}xml_soup=BeautifulSoup('<p class="body strikeout"></p>','xml',multi_valued_attributes=class_is_multi)xml_soup.p['class']# ['body', 'strikeout']

class_is_multi
=
{
'*'
:
'class'
}
xml_soup
=
BeautifulSoup
(
'<p class="body strikeout"></p>'
,
'xml'
,
multi_valued_attributes
=
class_is_multi
)
xml_soup
.
p
[
'class'
]
# ['body', 'strikeout']
You probably won't need to do this, but if you do, use the defaults as
a guide. They implement the rules described in the HTML specification:
frombs4.builderimportbuilder_registrybuilder_registry.lookup('html').DEFAULT_CDATA_LIST_ATTRIBUTES
frombs4.builderimportbuilder_registrybuilder_registry.lookup('html').DEFAULT_CDATA_LIST_ATTRIBUTES
frombs4.builderimportbuilder_registrybuilder_registry.lookup('html').DEFAULT_CDATA_LIST_ATTRIBUTES

from
bs4.builder
import
builder_registry
builder_registry
.
lookup
(
'html'
)
.
DEFAULT_CDATA_LIST_ATTRIBUTES
classNavigableString¶
classNavigableString¶
class
class

NavigableString
NavigableString
¶


A tag can contain strings as pieces of text. Beautiful Soup
uses theNavigableStringclass to contain these pieces of text:
NavigableString
NavigableString
NavigableString
soup=BeautifulSoup('<b class="boldest">Extremely bold</b>','html.parser')tag=soup.btag.string# 'Extremely bold'type(tag.string)# <class 'bs4.element.NavigableString'>
soup=BeautifulSoup('<b class="boldest">Extremely bold</b>','html.parser')tag=soup.btag.string# 'Extremely bold'type(tag.string)# <class 'bs4.element.NavigableString'>
soup=BeautifulSoup('<b class="boldest">Extremely bold</b>','html.parser')tag=soup.btag.string# 'Extremely bold'type(tag.string)# <class 'bs4.element.NavigableString'>

soup
=
BeautifulSoup
(
'<b class="boldest">Extremely bold</b>'
,
'html.parser'
)
tag
=
soup
.
b
tag
.
string
# 'Extremely bold'
type
(
tag
.
string
)
# <class 'bs4.element.NavigableString'>
ANavigableStringis just like a Python Unicode string, except
that it also supports some of the features described inNavigating
the treeandSearching the tree. You can convert aNavigableStringto a Unicode string withstr:
NavigableString
NavigableString
NavigableString
Navigating
the tree
Searching the tree
NavigableString
NavigableString
NavigableString
str
str
unicode_string=str(tag.string)unicode_string# 'Extremely bold'type(unicode_string)# <type 'str'>
unicode_string=str(tag.string)unicode_string# 'Extremely bold'type(unicode_string)# <type 'str'>
unicode_string=str(tag.string)unicode_string# 'Extremely bold'type(unicode_string)# <type 'str'>

unicode_string
=
str
(
tag
.
string
)
unicode_string
# 'Extremely bold'
type
(
unicode_string
)
# <type 'str'>
You can't edit a string in place, but you can replace one string with
another, usingreplace_with():
replace_with()
replace_with()
tag.string.replace_with("No longer bold")tag# <b class="boldest">No longer bold</b>
tag.string.replace_with("No longer bold")tag# <b class="boldest">No longer bold</b>
tag.string.replace_with("No longer bold")tag# <b class="boldest">No longer bold</b>

tag
.
string
.
replace_with
(
"No longer bold"
)
tag
# <b class="boldest">No longer bold</b>
NavigableStringsupports most of the features described inNavigating the treeandSearching the tree, but not all of
them. In particular, since a string can't contain anything (the way a
tag may contain a string or another tag), strings don't support the.contentsor.stringattributes, or thefind()method.
NavigableString
NavigableString
NavigableString
Navigating the tree
Searching the tree
.contents
.contents
.string
.string
find()
find()
If you want to use aNavigableStringoutside of Beautiful Soup,
you should callunicode()on it to turn it into a normal Python
Unicode string. If you don't, your string will carry around a
reference to the entire Beautiful Soup parse tree, even when you're
done using Beautiful Soup. This is a big waste of memory.
NavigableString
NavigableString
NavigableString
unicode()
unicode()

TheBeautifulSoupobject represents the parsed document as a
whole. For most purposes, you can treat it as aTagobject. This means it supports most of the methods described inNavigating the treeandSearching the tree.
BeautifulSoup
BeautifulSoup
Tag
Tag
Tag
Navigating the tree
Searching the tree
You can also pass aBeautifulSoupobject into one of the methods
defined inModifying the tree, just as you would aTag. This
lets you do things like combine two parsed documents:
BeautifulSoup
BeautifulSoup
Modifying the tree
Tag
Tag
Tag
doc=BeautifulSoup("<document><content/>INSERT FOOTER HERE</document","xml")footer=BeautifulSoup("<footer>Here's the footer</footer>","xml")doc.find(text="INSERT FOOTER HERE").replace_with(footer)# 'INSERT FOOTER HERE'print(doc)# <?xml version="1.0" encoding="utf-8"?># <document><content/><footer>Here's the footer</footer></document>
doc=BeautifulSoup("<document><content/>INSERT FOOTER HERE</document","xml")footer=BeautifulSoup("<footer>Here's the footer</footer>","xml")doc.find(text="INSERT FOOTER HERE").replace_with(footer)# 'INSERT FOOTER HERE'print(doc)# <?xml version="1.0" encoding="utf-8"?># <document><content/><footer>Here's the footer</footer></document>
doc=BeautifulSoup("<document><content/>INSERT FOOTER HERE</document","xml")footer=BeautifulSoup("<footer>Here's the footer</footer>","xml")doc.find(text="INSERT FOOTER HERE").replace_with(footer)# 'INSERT FOOTER HERE'print(doc)# <?xml version="1.0" encoding="utf-8"?># <document><content/><footer>Here's the footer</footer></document>

doc
=
BeautifulSoup
(
"<document><content/>INSERT FOOTER HERE</document"
,
"xml"
)
footer
=
BeautifulSoup
(
"<footer>Here's the footer</footer>"
,
"xml"
)
doc
.
find
(
text
=
"INSERT FOOTER HERE"
)
.
replace_with
(
footer
)
# 'INSERT FOOTER HERE'
print
(
doc
)
# <?xml version="1.0" encoding="utf-8"?>
# <document><content/><footer>Here's the footer</footer></document>
Since theBeautifulSoupobject doesn't correspond to an actual
HTML or XML tag, it has no name and no attributes. But sometimes it's
useful to reference its.name(such as when writing code that works
with bothTagandBeautifulSoupobjects),
so it's been given the special.name"[document]":
BeautifulSoup
BeautifulSoup
.name
.name
Tag
Tag
Tag
BeautifulSoup
BeautifulSoup
.name
.name
soup.name# '[document]'
soup.name# '[document]'
soup.name# '[document]'

soup
.
name
# '[document]'
Special strings¶Tag,NavigableString, andBeautifulSoupcover almost everything you'll see in an
HTML or XML file, but there are a few leftover bits. The main one
you'll probably encounter is theComment.classComment¶markup="<b><!--Hey, buddy. Want to buy a used parser?--></b>"soup=BeautifulSoup(markup,'html.parser')comment=soup.b.stringtype(comment)# <class 'bs4.element.Comment'>TheCommentobject is just a special type ofNavigableString:comment# 'Hey, buddy. Want to buy a used parser'But when it appears as part of an HTML document, aCommentis
displayed with special formatting:print(soup.b.prettify())# <b>#  <!--Hey, buddy. Want to buy a used parser?--># </b>For HTML documents¶Beautiful Soup defines a fewNavigableStringsubclasses to
contain strings found inside specific HTML tags. This makes it easier
to pick out the main body of the page, by ignoring strings that
probably represent programming directives found within the
page.(These classes are new in Beautiful Soup 4.9.0, and the
html5lib parser doesn't use them.)classStylesheet¶ANavigableStringsubclass that represents embedded CSS
stylesheets; that is, any strings found inside a<style>tag
during document parsing.classScript¶ANavigableStringsubclass that represents embedded
Javascript; that is, any strings found inside a<script>tag
during document parsing.classTemplate¶ANavigableStringsubclass that represents embedded HTML
templates; that is, any strings found inside a<template>tag during
document parsing.For XML documents¶Beautiful Soup defines someNavigableStringclasses for
holding special types of strings that can be found in XML
documents. LikeComment, these classes are subclasses ofNavigableStringthat add something extra to the string on
output.classDeclaration¶ANavigableStringsubclass representing thedeclarationat the beginning of
an XML document.classDoctype¶ANavigableStringsubclass representing thedocument type
declarationwhich may
be found near the beginning of an XML document.classCData¶ANavigableStringsubclass that represents aCData section.classProcessingInstruction¶ANavigableStringsubclass that represents the contents
of anXML processing instruction.
Special strings¶
¶
Tag,NavigableString, andBeautifulSoupcover almost everything you'll see in an
HTML or XML file, but there are a few leftover bits. The main one
you'll probably encounter is theComment.
Tag
Tag
Tag
NavigableString
NavigableString
NavigableString
BeautifulSoup
BeautifulSoup
Comment
Comment
Comment
classComment¶
classComment¶
class
class

Comment
Comment
¶

markup="<b><!--Hey, buddy. Want to buy a used parser?--></b>"soup=BeautifulSoup(markup,'html.parser')comment=soup.b.stringtype(comment)# <class 'bs4.element.Comment'>
markup="<b><!--Hey, buddy. Want to buy a used parser?--></b>"soup=BeautifulSoup(markup,'html.parser')comment=soup.b.stringtype(comment)# <class 'bs4.element.Comment'>
markup="<b><!--Hey, buddy. Want to buy a used parser?--></b>"soup=BeautifulSoup(markup,'html.parser')comment=soup.b.stringtype(comment)# <class 'bs4.element.Comment'>

markup
=
"<b><!--Hey, buddy. Want to buy a used parser?--></b>"
soup
=
BeautifulSoup
(
markup
,
'html.parser'
)
comment
=
soup
.
b
.
string
type
(
comment
)
# <class 'bs4.element.Comment'>
TheCommentobject is just a special type ofNavigableString:
Comment
Comment
Comment
NavigableString
NavigableString
NavigableString
comment# 'Hey, buddy. Want to buy a used parser'
comment# 'Hey, buddy. Want to buy a used parser'
comment# 'Hey, buddy. Want to buy a used parser'

comment
# 'Hey, buddy. Want to buy a used parser'
But when it appears as part of an HTML document, aCommentis
displayed with special formatting:
Comment
Comment
Comment
print(soup.b.prettify())# <b>#  <!--Hey, buddy. Want to buy a used parser?--># </b>
print(soup.b.prettify())# <b>#  <!--Hey, buddy. Want to buy a used parser?--># </b>
print(soup.b.prettify())# <b>#  <!--Hey, buddy. Want to buy a used parser?--># </b>

print
(
soup
.
b
.
prettify
())
# <b>
#  <!--Hey, buddy. Want to buy a used parser?-->
# </b>
For HTML documents¶Beautiful Soup defines a fewNavigableStringsubclasses to
contain strings found inside specific HTML tags. This makes it easier
to pick out the main body of the page, by ignoring strings that
probably represent programming directives found within the
page.(These classes are new in Beautiful Soup 4.9.0, and the
html5lib parser doesn't use them.)classStylesheet¶ANavigableStringsubclass that represents embedded CSS
stylesheets; that is, any strings found inside a<style>tag
during document parsing.classScript¶ANavigableStringsubclass that represents embedded
Javascript; that is, any strings found inside a<script>tag
during document parsing.classTemplate¶ANavigableStringsubclass that represents embedded HTML
templates; that is, any strings found inside a<template>tag during
document parsing.