Top 50 Android Interview Questions and Answers – SDE I to SDE III Last Updated : 17 Mar, 2025 Comments Improve Suggest changes Like Article Like Report A Linux-based open-source OS, Android was created by Andy Rubin and became one of the most popular smartphone operating systems. With 71 percent of the market share worldwide, Android is on top. Because it is on top in the smartphone OS, Android development is always in demand. If you are seeking a job in Android development, then this interview preparation guide is the right place for you. Here we have listed the top 50 50 Android interview questions and answers for beginners, as well as  SDE I to SDE III. Most Asked Android Interview Questions in 2025 1. What do you understand by the term “Android” and what is the latest version of Android? Android is an operating system that is built basically for Mobile phones. It is based on the Linux Kernel and other open-source software and is developed by Google. It is used for touchscreen mobile devices such as smartphones and tablets. But nowadays these are used in Android Auto cars, TV, watches, cameras, chromebooks, etc. It has been one of the best-selling OS for smartphones. Android OS was developed by Android Inc. The latest version of Android is Android 15 (API level 35) and the initial stable release date is October 15, 2024 . The next version Android 16 (API level 26) is announced to be released in June 2025. To know more about topic refer to Introduction to Android . 2. What’s Activity in Android? The Activity class is a fundamental component of Android applications. Any app, no matter how small it is (in terms of code and scalability), has at least one Activity class. Unlike most programming languages, in which the main() method is the entry point for that program or application to start its execution, the Android operating system initiates the code in an Activity instance by invoking specific callback methods that correspond to specific stages of its lifecycle. So it can be said that an activity is the entry point for interacting with the user. Check this article to learn more about Activities in Android . 3. Why is XML used for frontend development in Android? XML stands for Extensible Markup Language . XML is a markup language much like HTML used to describe data. XML itself is well readable both by humans and machines. Android uses XML for UI development for the following reasons: XML is lightweight, which make UI layouts fast and responsive. It separates the UI design from the application code (written in Java or Kotlin), make it a cleaner code structure. XML is easy to read, modify, and maintain, making UI updates simpler. XML supports nested layouts, making it easier to design complex UI components while keeping the code organized. 4. What are the components of the Android Application? There are some necessary building blocks that an Android application consists of. These loosely coupled components are bound by the application manifest file which contains the description of each component and how they interact. The five main components of Android applications are: Activities Services Content Providers Broadcast Receivers Intents To learn about topic in depth refer to Components of an Android Application . 5. What is the Dalvik Virtual Machine? DVM is a virtual machine to execute Android applications. The Java bytecode (.class file) generated by the javac compiler is converted into Dalvik bytecode to make the application source files executable on the DVM. Since Android devices have a definite processing capacity, memory, and battery life, the DVM design principle aims to optimize itself so that it can load fastly and run smoothly even on low memory/powered devices. This virtual machine is very efficient in running multiple instances on the same device. With the release of Android 5.0 (Lollipop), Android Runtime (ART) replaced DVM as the default runtime environment. ART improves performance by compiling apps ahead of time (AOT) rather than using just-in-time (JIT) compilation like DVM. However, DVM played a crucial role in shaping Android’s early performance and efficiency standards. To learn more about Dalvik Virtual machnine refer to DVM article. 6. What are the differences between Dalvik and ART? Feature Dalvik Virtual Machine Android Run Time Boot Time Faster Booting time Rebooting is significantly longer Cache Handling Cache builds up overtime The cache is built during the first boot Storage Usage Occupies less space due to JIT Consumes a lot of storage space internally due to AOT Device Suitability Works best for small storage devices Works best for Large storage devices Stability Stable and tested virtual machine Experimental and new – not much app support comparatively App Loading Time Longer app loading time Extremely Faster and smoother Faster and app loading time and lower processor usage Compilation Type Uses JIT compiler (Just-In-Time) Thereby resulting in lower storage space consumption Uses AOT compiler (Ahead-Of-Time) thereby compiling apps when installed App Performance Application lagging due to garbage collector pauses and JIT Reduced application lagging and better user experience App Installation Time Comparatively lower as the compilation is performed later Longer as compilation is done during installation Battery Life DVM converts bytecode every time you launch a specific app. ART converts it just once at the time of app installation. That makes CPU execution easier. Improved battery life due to faster execution. To read more, refer to the article: Difference Between Dalvik and ART in Android 7. How does an Android App Work? Developing an Android application involves several processes that happen sequentially. After writing the source code files, when developers click the Run button on the Android studio , plenty of operations and processes gets triggered under the hood. Building the APK File – The Android Package (APK) file is the final executable that contains the app’s code, resources, and metadata. The build process involves the following steps: Code Compilation Conversion into Dalvik bytecodes Generating .apk file App Distribution Deploy the Application – Installing the app into a physical device or an emulator. This includes the following steps: Establish the ADB Server Transfer .apk file to the Device Run the Application App launch request Conversion of the .dex code to native OAT format 8. What is Toast in Android? A Toast is a non-intrusive (without interrupting the app) short alert message (kind of like a in-app notification) shown on the Android screen for a short interval of time. Android Toast is a short popup notification that is used to display information when we perform any operation in our app. It disappears automatically. If the user wants a permanently visible message, then a notification can be used. 9. What are Services in Android? Services are a special component that allows an application to run in the background in order to perform long-running operations . The prime aim of a service is to ensure that the application remains active in the background so that the user can operate multiple applications at the same time. A user interface is not desirable for Android services as it is designed to operate long-running processes without any user intervention. A service can run continuously in the background even if the application is closed or the user switches to another application. Services are primarily used for the following purposes: Background Processing – for eg. syncing data and fetching location updates. Playing media – for eg. music. Handling network requests – for eg. downloading files. Types of Services Foreground Services – Runs in the background with a persistent notification. Background Services – Runs in the background without user interaction. Bound Services – This allows Inter-Process Communication (IPC) between the service and other app components. 10. What is a Content Provider in Android? Content Provider is a very important component that is used to manage and share data between applications securely. The role of the content provider in the Android system is like a central repository in which data of the applications are stored, and it facilitates other applications to securely access and modify that data based on the user requirements.  The Android system allows the content provider to store the application data in several ways. Users can manage to store the application data like images, audio, videos, and personal contact information by storing them in SQLite Database, in files, or even on a network. Components of Content Provider: URI (Uniform Resource Identifier) – Identifies unique data exposed by the content provider. Content Resolver – Works like a bridge between the app and the content provider to query, insert, update and delete data. Cursor – It is used to read the results from a query of content provider. Contract Class – Used to define and maintain constants. 11. What are Broadcast Receivers in Android? Broadcasts are system-wide events or messages that can occur when the device starts, when a message is received on the device, when incoming calls are received, or when a device goes to airplane mode, etc. Broadcast Receivers , a component in android, are used to respond to these system-wide events. Broadcast Receivers allow us to register for the system and application events, and when that event happens, the registered receivers get notified. Types of Broadcast Receivers: Static Receivers: These types of Receivers are declared in the manifest file and work even if the app is closed. Used for system specific broadcasts. Dynamic Receivers: These types of receivers are declared in code and work only if the app is active or minimized. Used for app specific broadcasts. 12. What is Gradle and write down its usage in Android? Gradle is a build tool (open source) that is used to automate compile, package, and deployment. “Build.gradle” are scripts where one can automate the tasks. For example, the simple task to copy some files from one directory to another can be performed by Gradle build script before the actual build process happens. Usage: Every Android project needs a Gradle for generating an apk from the .java, .kt and .xml files in the project. Simply put, a Gradle takes all the source files (java, Kotlin and XML) and applies appropriate tools, e.g., converts the Kotlin/Java files into dex files and compresses all of them into a single file known as apk that is actually used. 13. What is a Fragment in Android? A Fragment is a reusable UI component that represents a portion of the User Interface(UI) within a activity. It is the modular section of the Android activity that is very helpful in creating UI designs that are flexible in nature and auto-adjustable based on the device screen size. There are mainly 3 types of fragments: Static Fragment – Declared as a XML layout. Dynamic Fragment – Defined during runtime using FragmentManager. Dialog Fragment – Used for pop-up dialogs using DialogFragment. Follow Up Question: Difference between Fragment and Activity? on Question 22. 14. What’s RecyclerView in Android & How it works? RecyclerView in Android is an advanced version of ListView and GridView. It is a flexible list/grid management UI component that helps in efficiently displaying large datasets by recycling views. It has been created to make possible construction of any lists with XML layouts as an item that can be customized vastly while improving the efficiency of ListViews and GridViews . This improvement is achieved by recycling the views which are out of the visibility of the user. For example, if a user scrolled down to a position where items 4 and 5 are visible; items 1, 2, and 3 would be cleared from the memory to reduce memory consumption. 15. What’s the Difference Between Intent and Intent filters? In simple terms, Intent is a message (for eg. a phone call) and Intent filters is a receiver capabilities (for eg. who can receive the call). Intent Intent Filter Intents are messaging objects used to request an action from an app component like activities, services, etc. Intent filters are declared in the manifest files to determine the type of intents app component can respond to. Intents are used to launch activities, services or send broadcasts. Intent filters are used to allow external app to communicate with an app component. Intents are two types – Implicit and Explicit Intent. Intent filters are mainly three types – action, category and data. To read more, refer to the article: Difference Between Implicit Intent and Explicit Intent in Android 16. What is the AndroidManifest.xml? Every project in Android includes a manifest file, which is AndroidManifest.xml, stored in the root directory of its project hierarchy. The manifest file is an important part of our app because it defines the structure and metadata of our application, its components, and its requirements. This file includes nodes for each of the Activities, Services, Content Providers, and Broadcast Receivers that make the application and using Intent Filters and Permissions determines how they coordinate with each other and other applications. The manifest file also specifies the application metadata, which includes its icon, version number, themes, etc., and additional top-level nodes can specify any required permissions, unit tests, and define hardware, screen, or platform requirements. 17. What’s Android SDK and its Components? Android SDK (Android Software Development Kit) , developed by Google is a collection of tools, libraries and APIs, required to develop, test, debug and deploy any android applications. With the help of Android SDK, we can create Android Apps easily. Whenever Google releases a new version or update of Android Software, a corresponding SDK also releases with it. In the updated or new version of SDK, some more features are included which are not present in the previous version. Android SDK consists of some tools which are very essential for the development of Android Application. These tools provide a smooth flow of the development process from developing and debugging. Android SDK is compatible with all operating systems such as Windows, Linux, macOS, etc. Components: Android Emulator Android SDK Tools Android SDK Build tool Android SDK Platform-tools. Android Support Libraries (Jetpack) NDK (Native Development Kit) Google Play Services SDK Manager To read more about the topic refer to the article Android SDK and its Components . 18. Disadvantages of Android Fragment Issues – Since there are Multiple Android OS versions and different hardware for various devices in the markets, this leads to compatibility issues and delayed updates. Open Source – Since android is open-source, this makes it more vulnerable to malware than closed systems like IOS. Play store has less strict policies which leads to more malicious apps in the Playstore. Performance – Since multiple manufacturers add bloatware apps to their devices, this leads to slow device performance and battery drain. 19. Explain the Activity Lifecycle in brief. These are the different stages of the Activity Lifecycle: onCreate() : It is called when the activity is first created. This is where all the static work is done like creating views, binding data to lists, etc. onStart() : It is invoked when the activity is visible to the user. It is followed by onResume() if the activity is invoked from the background. onRestart() : It is invoked after the activity has been stopped and prior to its starting stage and thus is always followed by onStart() when any activity is revived from background to on the screen. onResume() : It is invoked when the activity starts interacting with the user. At this point, the activity is at the top of the activity stack, with a user interacting with it. onPause() : It is invoked when an activity is going into the background but has not yet been killed. It is a counterpart to onResume() onStop() : It is invoked when the activity is not visible to the user. It is followed by onRestart() when the activity is revoked from the background, followed by onDestroy() when the activity is closed or finished, and nothing when the activity remains on the background only. onDestroy() : The final call received before the activity is destroyed. This can happen either because the activity is finished (when finish() is invoked) or because the system is temporarily destroying this instance of the activity to save space. 20. Why do we need to call setContentView() in onCreate() of Activity class? The setContentView() is called on the onCreate() method to set the UI layout of the activity. It is defined especially in the onCreate() method because it the first function called when the activity starts, so it would be the most reasonable to load the UI first before the user can interact with the UI. 21. Explain the Fragment Lifecycle in Brief. These are the different stages of the Activity Lifecycle: Methods Description onAttach() The very first method to be called when the fragment has been associated with the activity. This method executes only once during the lifetime of a fragment. onCreate() This method initializes the fragment by adding all the required attributes and components. onCreateView() System calls this method to create the user interface of the fragment. The root of the fragment’s layout is returned as the View component by this method to draw the UI. onActivityCreated() It indicates that the activity has been created in which the fragment exists. View hierarchy of the fragment also instantiated before this function call. onStart() The system invokes this method to make the fragment visible on the user’s device. onResume() This method is called to make the visible fragment interactive. onPause() It indicates that the user is leaving the fragment. System calls this method to commit the changes made to the fragment. onStop() Method to terminate the functioning and visibility of fragments from the user’s screen. onDestroyView() System calls this method to clean up all kinds of resources as well as view hierarchy associated with the fragment. onDestroy() It is called to perform the final clean-up of the fragment’s state and its lifecycle. onDetach() The system executes this method to disassociate the fragment from its host activity. To read more about the topic refer to the article Fragment Lifecycle in Android . 22. What is the difference between a Fragment and an Activity? Activity Fragment Activity is an independant app component Fragment is dependent and is a part of an Activity. Activity is needed to be mentioned in the manifest file Fragment is not required to be mentioned in the manifest file Creating a project using only Activity then it’s difficult to manage, affect performance and increase app size. While Using fragments, the project will be much more manageable, better performance and lesser app size. Lifecycle methods are hosted by the OS. The activity has its own life cycle. Lifecycle methods in fragments are hosted by hosting the activity. Activity is not light weight. Too many of them can decrease app performance. The fragment is a lightweight component. 23. What’s Context in Android? Context is an abstract class that provides access to application-specific resources. It can be understood as something which gives us the context of the current state of our application. We can break the context and its use into three major points: It allows us to access resources. It allows us to interact with other Android components by sending messages. It gives you information about your app environment. There are mainly four types of context available in Android. Application Context – This is tied to the app’s lifecycle which is generally used to access databases and shared preferences. Activity Context – This is tied to an activity’s lifecycle which is generally used for UI related tasks like inflating views and starting a new activity. Service Context – This is used inside of a service and is generally used to access systems services like notification manager. Base Context – This is generally used in custom view components and libraries that extends the ContextWrapper class. 24. Top Image Loading Libraries in Android. Glide Coil (Coroutine Image Loader) Fresco Picasso UIL (Universal Image Loader) To read more, refer to the article: Top Image Loading Libraries in Android 25. What is View in Android? The view is a class that represents the basic building block for UI components. A View occupies a rectangular area on the screen and is responsible for drawing and event handling. It is a superclass for all the UI components. The most common UI components are: TextView EditText ImageView Button ProgressBar CheckBox, etc. 26. Difference Between View and ViewGroup in Android View ViewGroup It’s a UI element that has content, eg. TextView, ImageView, etc. It is a container that can hold multiple views and viewgroups eg. ConstraintLayout, LinearLayout, etc. It displays UI content. It organizes multiple views and viewgroups. It does not contain a child. It can contain mulitple children like a view or a viewgroup. Handles individual user interaction. Passes its user interaction to it’s child views unless overriden. It extends the android.view.View class It extends the android.view.ViewGroup class. 27. What is Kotlin Coroutine on Android? The Kotlin team defines coroutines as “ lightweight threads ”. They are sort of tasks that the actual threads can execute. Kotlin coroutines introduce a new style of concurrency that can be used on Android to simplify asynchronous programming. By lightweight, it means that creating coroutines doesn’t allocate new threads. Instead, they use predefined thread pools and smart scheduling for the purpose of which task to execute next and which tasks later. 28. How Garbage Collector Works in Android? Garbage Collector is a process that automatically reclaims memory occupied by objects that are no longer in use. It has no compacting. This means the address of objects in the heap never changed after their creation. So garbage collection can be triggered when an allocation fails when an OutOfMemoryError is about to be triggered, When the size of the heap hits some soft limit, and When a GC was explicitly requested. 29. Describe the architecture of your last app. When developers work on a real mobile application whose nature is dynamic and will expand its features according to the user’s need, then it is not possible to write core logic in activities or fragments. To structure the project’s code and to give it a modular design(separated code parts), architecture patterns are applied to separate the concerns. The most popular Android architectures used by developers are the following: MVC (Model — View — Controller) MVP (Model — View — Presenter) MVVM (Model — View — ViewModel) So you have to tell the architecture of the last app you have developed during the college time project or in a real industry project. To learn about the concept refer this article Android Architecture Patterns . 30. MVC vs MVP vs MVVM architecture and which one we should choose? MVC(MODEL VIEW CONTROLLER) MVP(MODEL VIEW PRESENTER) MVVM(MODEL VIEW VIEWMODEL) One of the oldest software architecture Developed as the second iteration of software architecture which is advanced from MVC. Industry-recognized architecture pattern for applications. View-Logic Separation is very poor. View-Logic Separation is Good. View-Logic Separation is Excellent. UI( View ) and data-access mechanism( Model ) are tightly coupled. It resolves the problem of having a dependent View by using Presenter as a communication channel between Model and View . This architecture pattern is more event-driven as it uses data binding and thus makes easy separation of core business logic from the View . Controller and View exist with the one-to-many relationship. One Controller can select a different view based upon the required operation. A one-to-one relationship exists between Presenter and View as one Presenter class manages one View at a time. Multiple View can be mapped with a single ViewModel and thus, the one-to-many relationship exists between View and ViewModel. Doesn’t support data binding Doesn’t support data binding Supports data binding using LiveData and StateFlow. Which one should we choose? MVC: Ideal for small-scale projects only. MVP: Ideal for simple and complex applications. MVVM: Ideal for big-scale projects. But not ideal for small-scale projects. To learn about the difference between them refer to MVC Vs MVP Vs MVVM Architecture Pattern in Android article. 31. How to Reduce APK size in Android? Remove unused sources Use of Vector Drawables Reuse your code Compress PNG and JPEG files Use of Lint Use images in WebP file format Use of proguard Use of ShrinkResources Limit the usage of external libraries Use the Android Size Analyzer tool Generate App Bundles instead of APK Use of Resconfigs Check this link explaining How to Reduce APK Size in Android in depth. 32. What’s the Android jetpack and its Key Benefits? Jetpack is nothing but a set of software components, libraries, tools, and guidance to help in developing great Android apps. Google launched Android Jetpack in 2018. Key Benefits of Android Jetpack Forms a recommended way for app architecture through its components Eliminate boilerplate code Simplify complex task Provide backward compatibility as libraries like support are unbundled from Android API and are re-packaged to androidx.* package Inbuilt productivity feature of the Kotlin Integration 33. What are the different software components of Android Jetpack? The software components of Android Jetpack has been divided into 4 categories: Foundation Components: AppCompat, Android KTX, Test, Multidex Architecture Components: Room, WorkManager, Lifecycle, ViewModel, Paging, Navigation Behavior Components: DownloadManager, Permissions, Sharing, Slices UI Components: Animation & Transition, Auto, Fragment, Palette, Layout 34. What’s Jetpack Compose and its Benefits? Jetpack Compose is a modern UI toolkit recently launched by Google which is used for building native Android UI. It simplifies and accelerates the UI development with less code, Kotlin APIs, and powerful tools. Declarative Compatible Increase development speed Concise and Idiomatic Kotlin Easy to maintain Written in Kotlin 35. What are the Architecture Components of Android? Architecture Components could be classified as follows: Room – A library that makes working with databases easier by simplifying SQLite. WorkManager – Runs background tasks even after app closes. Lifecycle – Handles from the create to the destroy of an UI component it from crashing. ViewModel – Manages UI data even when the screen rotates. LiveData – Used to automatic and live UI updates whenever data changes. Navigation – Used to move between screens and handle back navigation to prevent stack overflow. Paging – Helps in loading large datasets without using too much memory by loading only chunks of data. Data Binding – Binds UI elements directly to the data prevently a lot of boiler plate code and also increasing performance. 36. How to Improve RecyclerView Scrolling Performance in Android? Avoid dynamic image resizing by setting a specific width and height to ImageView in RecyclerView items Avoid nesting RecyclerView inside another, this will result in lagging, use ConcatAdapter instead. Enable setHasFixedSize(true) to improve performance by letting recyclerview know that the size won’t change. Use image loading libraries like Glide, Coil or Picasso for efficiently loading images Avoid heavy operations in the OnBindViewHolder method like calculation, database calls, etc. Use notifyItemInserted(), notifyItemRemoved(), etc instead of the notifyDataSetChanged() for better performance. To read more, refer to the article: How to Improve RecyclerView Scrolling Performance in Android? 37. Volley Library in Android Volley is an HTTP library that makes networking very easy and fast, for Android apps. It was developed by Google and introduced during Google I/O 2013. It was developed because there is an absence in Android SDK, of a networking class capable of working without interfering with the user experience. Although Volley is a part of the Android Open Source Project(AOSP), Google announced in January 2017 that Volley will move to a standalone library. It manages the processing and caching of network requests, and it saves developers valuable time from writing the same network call/cache code again and again. 38. What’s Retrofit in Android? Retrofit is a type-safe HTTP client built by square for Android and Java which intends to make it simpler to call REST APIs. It provides an easy-to-use interface for network requests and handles JSON parsing automatically. How Retrofit Works? Uses OkHttp as the underlying network layer. Converts JSON files into POJO (Plain Old Java Objects) automatically. Requires a converter (eg. Gson) to serialize/deserialize JSON. Uses annotations (@GET, @POST, @Query, etc.) to define API calls. Supports synchronous, asynchronous, and coroutines-based API calls. Retrofit enables automatic json parsing, clean and type-safe api calls, and supports Kotlin Coroutines which proves it as a better alternative for Volley. Though there are still a few limitations to Retrofit such as it doesn’t support built-in image loading unlike Volley and is not ideal for large file downloads unlike OkHttp or WorkManager. 39. Describe MVVM Model — View — ViewModel (MVVM) is the industry-recognized software architecture pattern that overcomes all drawbacks of MVP and MVC design patterns. MVVM suggests separating the data presentation logic(Views or UI) from the core business logic part of the application. The separate code layers of MVVM are: Model: This layer is responsible for the abstraction of the data sources. Model and ViewModel work together to get and save the data. View: The purpose of this layer is to inform the ViewModel about the user’s action. This layer observes the ViewModel and does not contain any kind of application logic. ViewModel: It exposes those data streams which are relevant to the View. Moreover, it serves as a link between the Model and the View. To read more, refer to the article: MVVM (Model View ViewModel) Architecture Pattern in Android 40. What are the reasons your Android app is lagging? You are doing too much on the main thread Your asset files are huge You are using an outdated SDK version You are using bad libraries The speed of the network Chatty conversations Your code is inefficient 41. What is AIDL? AIDL (Android Interface Definition Language) is a mechanism in android that allows processes to interact or communicate with each other. On Android what happens with the processors is one process can’t normally access the memory of another process. So in order to interact they need to decompose their objects into primitives that the OS can understand and gather the objects across that boundary. The code to do that gathering is very complex to write, so Android handles it with AIDL. So generally AIDL is similar to the other IDLs and it allows to define the programming interface that both the client and service agree upon in order to interact with each other using interprocess communication (IPC). 42.  What is ANR and How can it be Prevented in Android? An ANR (Application Not Responding) will occur if you’re running a process on the UI thread which takes an extended time , usually around 5 seconds. During this point, the GUI (Graphical User Interface) will be freezed and won’t respond to user inputs. After the 5 second mark, if the thread still hasn’t recovered then an ANR dialogue box is shown informing the user that the appliance isn’t responding and can give the user the choice to either wait, in the hope that the app will eventually recover, or to force close the app. How to prevent ANRs? Stop doing heavy tasks on the main thread. Instead, use worker threads such as IntentService, AsyncTask Handler, or another Thread simply. Detecting where ANRs happen is straightforward if it’s a permanent block (deadlock acquiring some locks for instance), but harder if it’s just a short-lived delay. First, re-evaluate your code and appearance for vulnerable spots and long-running operations. To read more, refer to the article: What is ANR and How it Can be Prevented in Android? 43. What is Android NDK and why is it useful? The NDK (Native Development Kit) is a tool that allows developers to write part of their code in C/C++ rather than Java/Koltin. It allows the app to interact with low level system components and provide access to native libraries to increase performance. NDK can be useful for cases in which you need to do one or more of the following: Squeeze extra performance out of a device to achieve low latency or run computationally intensive applications, such as games or physics simulations. Reuse your own or other developers’ C or C++ libraries. Access low level system components like sensors, camera or graphics. For manual memory management, avoiding Java/Kotlin’s Garbage Collection (GC) pauses that can introduce latency. 44. Explain the JUnit test in brief. JUnit is a Unit Testing framework for Java Applications which is already included by default in Android studio. It supports automated unit and UI testing with annotations like @Test, @Before, and @After to define test cases and setup/teardown methods. JUnit helps ensure code correctness by automating test execution, making development more efficient and reliable. To Learn more about the topic refer to Unit Testing in Android using JUnit . 45. What’s Dagger and When to use Dagger? Dagger is a Dependency Injection (DI) framework automatically sets up dependency injection by generating boilerplate code at compile time. Dagger is faster, more efficient and well suited for Android Development unlike other DI frameworks. When to use a dagger? Project Size Recommended DI Approach Small Manual DI/Service Locator Medium Service Locator/Dagger Larger Dagger 46. What’s LiveData in Android Architecture Component and its Advantages? LiveData is an observable data holder that is lifecycle-aware which means it automatically updates UI components without interfering with there lifecycle states. Furthermore, it only updates the UI component if the observer’s lifecycle state is active i.e., either STARTED or RESUMED. LiveData always checks the observer’s state before making any update to ensure that the observer must be active to receive it. If the observer’s lifecycle state is destroyed, LiveData is capable of removing it, and thus it avoids memory leaks. It makes the task of data synchronization easier. Advantages of LiveData component: UI is automatically updated as per the appropriate change in the data It removes the stopped or destroyed activities which reduce the chance of app crash Prevents memory leaks as LiveData is a lifecycle-aware component. To read more, refer to the article Jetpack Architecture Components in Android . 47. What’s Data Binding in Android? Data Binding library is a support library that provides the feature of binding UI components in an activity/fragment to the data sources of the application instead of traditionally declaring individual views using findViewById() . The library carries out this binding task in a declarative format and not in a programmatic way. Below is an example to understand the working of this library accurately: Without Data Binding: TextView textView = findViewById(R.id.sample_text); textView.setText(viewModel.getUserName()); With Data Binding: <TextView .... android:text=”@{viewmodel.userName}” .... /> Advantages of Data Binding Component: Make code simpler and easy to maintain by removing UI frameworks called in the activity. Allows classes and methods to observe changes in data Allows to make objects and fill which works as collection observables. 48. What is Room in Android Architecture Component? The requirement of a database in Android is fulfilled by SQLite from the very beginning. However, it comes with some severe drawbacks like not checking the queries at compile-time, it does not save plain-old-Java Objects(commonly referred to as POJOs). Developers also need to write a lot of boilerplate code to make the SQLite database work in the Android OS environment. The Room component comes into the picture as an SQLite Object Mapping Library which overcomes all the mentioned challenges. Room converts queries directly into objects, checks errors in queries at the compile-time, and is also capable of persisting the Java POJOs. Moreover, it produces LiveData results/observables from the given query result. Because of this versatile nature of the Room component, Google officially supports and recommends developers to use it. The Room consists of the following sub-components: Entity: It is the annotated class for which the Room creates a table within the database. The field of the class represents columns in the table. DAO(Data Access Object): It is responsible for defining the methods to access the database and to perform operations. Database: It is an abstract class that extends RoomDatabase class and it serves as the main access point to the underlying app’s relational data. To read more, refer to the article: Jetpack Architecture Components in Android . 49. What is ViewModel in Android? ViewModel is a lifecycle aware jetpack component in Android whose main responsibility is to store and manage UI related data while surviving sudden lifecycle changes like screen rotation. It helps in separation of concerns to separate UI code with business logic. This helps is managing the app more easily and making it more maintainable. 50. What is Android KTX? KTX library is the only one among the foundation components which was introduced for the first time with the release of the Jetpack. Android KTX is a collection of Kotlin extensions that are designed to facilitate developers to remove boilerplate code as well as to write concise code while developing Android applications with Kotlin language. Here KTX in the name stands for Kotlin Extensions . Below is an example of a piece of code without using and after using the Android KTX library: Code snippet of SQLite without using KTX library: db.beginTransaction() try { // insert data db.setTransactionSuccessful() } finally { db.endTransaction() } Above code after using KTX library: db.transaction { // insert data } To read more, refer to the article Foundation Components of Android Jetpack . Additional Questions in Android 1. What is Pagination? Pagination in a process that includes loading large amounts of data incrementally rather than loading all the data at the same time. This helps in improving app performance and reduces memory usage. There are mainly two approaches to implement pagination in android : Manual Pagination: This is implemented by using a scroll listener which best suited for APIs that contains page numbers or limit-offsets. We do this by loading data when the user scrolls at the end of the page. Paging 3 Library: An official library included in Jetpack, this provides efficient and automatic pagination. This is a recommended method over manual pagination. To learn more about the topic refer to the articles mentioned below: Pagination in Android RecyclerView using Volley Paging Library in Android 2. What is an inline function? Inline function in Kotlin is like using a cheat to get better performance. Whenever we call a function, generally what the compiler does is, it jumps to the the function and comes back. But, when a function is marked as inline , the compiler just copies the code of the function and pastes it wherever its called. This helps in avoiding the jump to decrease that performance overhead. inline fun example() { // add your code here } To read more, refer to the article Kotlin Inline Functions . 3. What is Multidex? When we write code using Java/Kotlin, the code gets compiled into .class files which can’t be run by Android, so it get converted into .dex (Dalvik Executable) files. Now, a Dex file has a limit of 64k methods. When this limit is cross, more dex files are needed to be generated. Here’s where Multidex comes in. Multidex allows android to spilt the methods into multiple dex files which allows the app to have more than 64k methods. To Learn more the topic in depth refer to Multidex in Android . 4. What is the difference between Launch and Async in Kotlin Coroutines? Both Launch and Async has a similar use case, which is to start coroutines in Kotlin, but the basic difference between them is how they return the results and how they are used. Launch: Launch is used for the Fire & Forget case. This is when you want to launch a coroutine but don’t want a result and don’t need to wait for it to finish. For eg. Updating UI, logging, network calls, etc. Async: Async is used when you want a result after you wait for the coroutine to finish. For eg, fetching data for API, database queries, etc. To read more, refer to the article Launch vs Async in Kotlin Coroutines . 5. Explain the Android App Startup Process: Cold, Warm and Hot Start When we run an app, the startup experience varies on whether the app is starting from scratch, or its partially in memory or its already running in the foreground. These states are divided into three ways: Cold Start – This happens when the app is launched after a complete reboot and the system killed the app to free up memory. Warm Start – This happens when the app was recently closed but is still in the memory. For eg. waking up a laptop from sleep mode. Hot Start – This happens when the app is still running in the foreground and the user just returns to it. For eg. switching between apps from recent tabs. 6. Explain @JVMStatic, @JVMOverloads, and @JVMField in Kotlin. The JVMStatic, JVMOverloads, and JVMField annotations help Kotlin interoperate smoothly with Java by modifying how Kotlin properties and functions are exposed to Java. JVMStatic – This marks a method inside a companion object or object as a static method in Java. Use when you need a static method in Java without requiring a Companion reference. JVMOverloads – This generates multiple overloaded methods for functions with default arguments when called from Java. Use when you want Kotlin’s default arguments to work as overloaded methods in Java. JVMField – This exposes a Kotlin property directly as a public field in Java, bypassing getters and setters. Use when you want direct field access in Java without generating getters/setters. To read more, refer to the article: JvmStatic, JvmOverloads, and JvmField in Kotlin . Comment More info Advertise with us A AmiyaRanjanRout Follow Improve Article Tags : Android Interview Questions Interview-Questions